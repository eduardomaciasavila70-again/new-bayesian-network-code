# -*- coding: utf-8 -*-
"""Copia de RB_Marzo_2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u6r6p7XulCdWVjIevKrf8G_n_nUKTn3x

**AN EXAMPLE TAKEN FROM THE BOOK EXPERT SYSTEMS AND PROBABILISTIC NETWORKS BY E. CASTILLO ET AL. \cite{CASTILLO} IS PRESENTED. IT ADDRESSES A PRESSURIZED FLUID STORAGE TANK, WHERE THE FLUID IS INTRODUCED WITH THE AID OF A PRESSURE VESSEL. THE OPERATION OF THE EQUIPMENT AND THE CONTROL SYSTEM IS DESCRIBED IN GREATER DETAIL IN THE REFERENCED BOOK. FIGURE 11 SHOWS THE BAYESIAN NETWORK USED IN THIS EXAMPLE. THE NODES AND ARCS REPRESENT THE CONDITIONAL PROBABILITY RELATIONSHIPS AMONG THE VARIABLES. THIS BAYESIAN NETWORK IS USED TO DETERMINE THE FAILURE PROBABILITIES OF THE EQUIPMENT. THE TABLE 4 PRESENTS THE VALUES USED FOR THE BAYESIAN NETWORK IN THIS CASE.**

**ANOTHER WAY IN WHICH THIS METHOD CAN BE USED IS FOR THE COMPUTATION OF THE MOST PROBABLE EXPLANATION (MPE), WHICH INVOLVES FINDING THE TOP-K MOST PROBABLE EXPLANATIONS GIVEN THE OBSERVED EVIDENCE. LET US CONSIDER THE PREVIOUS CASE WHERE THE EVIDENCE IS D = 1, F = 1, AND J = 1. WE CALCULATE THE MOST PROBABLE EXPLANATION (MPE) STARTING FROM NODE J. **

FIRST PART: CREATION OF BAYESIAN NETWORK AND CALCULATION OF PROBABILITY VALUES USING THE STANDARD METHOD

SECOND PART:  CALCULATION OF PROBABILITY VALUES USING THE NEW METHOD

THIRD PART: CALCULATION OF PROBABILITIES IN THE BAYESIAN NETWORK

FOURTH PART: MPE CALCULATION STARTING FROM EVIDENCE NODE J

**FIRST PART: CREATION OF BAYESIAN NETWORK AND CALCULATION OF PROBABILITY VALUES USING THE STANDARD METHOD**

Installation of libraries of Bayesian Networks
"""

!pip  install pyagrum       # instalacion de libreria
import pyagrum as gum

import pyagrum.lib.notebook as gnb

import numpy as np          # importar  librerias  numericas de python
import matplotlib.pyplot as plt

import pandas as pd

"""Creation of the Bayesian network from the example in Castillo’s Expert Systems book"""

R0=['A',['A'],[],[0.998,0.002]]
R1=['B',['B'],[],[0.999,0.001]]
R2=['C',['C'],[],[0.997,0.003]]
R3=['D',['D'],[],[0.99,0.010]]
R4=['E',['E'],[],[0.999,0.001]]
R5=['F',['F'],[],[0.99,0.010]]
R6=['G',['G'],['D','F'],[1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0]]
R7=['H',['H'],['E','G'],[1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0]]
R8=['I',['I'],['A','H'],[1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0]]
R9=['J',['J'],['C','I'],[1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0]]
R10=['K',['K'],['B','J'],[1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0]]
Red=[R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10]

bn=gum.BayesNet()      # aqui se construye la red bayesiana , definiendo las las variables , se genera un diccionario para tener localizadas las variables
var={}
j=0
for i in Red:
  bn.add(i[0], 2)
  var[i[0]]=j
  j=j+1
print(var)

for i in Red:                  # definicion d elos arcos entre las variables, aqui se ve porque tuve que hacer el diccionario
  ind=len(i[2])
  if ind>0:
    for j in range(0,ind):
      var1=var[i[0]]
      var2=var[i[2][j]]
      bn.addArc(var2,var1)

for i in Red:                     # poner las probabilidades condicionales en la red bayesiana
  ind=len(i[2])
  if ind==0:
    t=[i[3][0],i[3][1]]
    t1=var[i[0]]
    bn.cpt(t1).fillWith(t)


  elif ind==1:
    t1=var[i[0]]
    bn.cpt(t1)[{i[2][0]:0}]=[i[3][0],i[3][1]]
    bn.cpt(t1)[{i[2][0]:1}]=[i[3][2],i[3][3]]


  elif ind==2:
    t1=var[i[0]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:0}]=[i[3][0],i[3][1]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:1}]=[i[3][2],i[3][3]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:0}]=[i[3][4],i[3][5]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:1}]=[i[3][6],i[3][7]]


  elif ind==3:
    t1=var[i[0]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:0,i[2][2]:0}]=[i[3][0],i[3][1]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:0,i[2][2]:1}]=[i[3][2],i[3][3]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:1,i[2][2]:0}]=[i[3][4],i[3][5]]
    bn.cpt(t1)[{i[2][0]:0,i[2][1]:1,i[2][2]:1}]=[i[3][6],i[3][7]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:0,i[2][2]:0}]=[i[3][8],i[3][9]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:0,i[2][2]:1}]=[i[3][10],i[3][11]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:1,i[2][2]:0}]=[i[3][12],i[3][13]]
    bn.cpt(t1)[{i[2][0]:1,i[2][1]:1,i[2][2]:1}]=[i[3][14],i[3][15]]

gnb.showBN(bn)

ie=gum.LazyPropagation(bn)
ie

dict={}
df=pd.DataFrame(dict,index=['A','B','C','D','E','F','G','H','I','J','K'])

"""Marginal Probability"""

nn=[]
for r in Red:
  var=r[0]
  print(ie.posterior(var))
  pp=ie.posterior(var)
  nn.append(round(pp[1],4))
df['MP BN']=nn

df

"""probability when F=1 and D=1"""

ie.setEvidence({'F':1,'D':1})
ie.makeInference()
nn=[]
for r in Red:
  var=r[0]
  print(ie.posterior(var))
  pp=ie.posterior(var)
  nn.append(round(pp[1],4))
df['DF BN']=nn

df

"""probability when F=1 ,D=1 and J=1


"""

ie.setEvidence({'F':1,'D':1,'J':1})
ie.makeInference()
nn=[]
for r in Red:
  var=r[0]
  print(ie.posterior(var))
  pp=ie.posterior(var)
  nn.append(round(pp[1],4))
df['DFJ BN']=nn

df

"""**SECOND PART:  CALCULATION OF PROBABILITY VALUES USING THE NEW METHOD**

Programs generated for calculation of probabilities of bayesian network using the new method
"""

# generacion de codificacion
def codigo(nn):
  m=2**nn
  mm=list(range(m))
  mb = [bin(num)[2:].zfill(nn) for num in mm]
  return mb

def variable_probability(VAR, var):
    """
    Calcula la probabilidad de que la variable 'var' (por nombre o índice)
    tome el valor 1.

    VAR: lista de dos elementos.
         VAR[0] es la lista de nombres de variables.
         VAR[1] es la lista de probabilidades para cada combinación de valores.
         Se asume que hay 2^n combinaciones para n variables.
    var: puede ser el nombre de la variable (str) o su índice (int).
    """
    variables = VAR[0]
    probs = VAR[1]
    n = len(variables)

    # Determinamos el índice de la variable si se pasó como nombre
    if isinstance(var, str):
        try:
            i = variables.index(var)
        except ValueError:
            raise ValueError(f"La variable {var} no se encuentra en la lista de variables.")
    elif isinstance(var, int):
        if 0 <= var < n:
            i = var
        else:
            raise ValueError(f"El índice debe estar entre 0 y {n-1}")
    else:
        raise ValueError("El parámetro 'var' debe ser un nombre (str) o un índice (int).")

    prob_sum = 0
    # Recorremos cada combinación representada por su índice j
    for j, p in enumerate(probs):
        # Convertimos j en binario y revisamos la posición correspondiente a la variable.
        # La variable en posición i corresponde al bit en la posición (n - 1 - i) de j.
        if j & (1 << (n - 1 - i)):
            prob_sum += p
    return prob_sum

import itertools
import numpy as np
import pdb

"""Subroutine for calculation of evidence propagation in the bayesian network

# **SUBROUTINES FOR FINAL CALCULATION**

**Subroutines For Evidence Propagation**
"""

# obtener una lista de codigos de numeros binarios
 def codigo(nn):
  mm=2**nn
  mb=[bin(num)[2:].zfill(nn) for num in range(mm)]
  return mb

codigo(3)

# obtener una lista de codigos de numeros intermedios binarios
def codigoInt(nn,np,val):

  # nn es un numero de datos, np es la posicion de dato a considerar (la posicion va de 0 a nn-1), val es el valor 0 o 1
  if (np==0):
    bb=codigo(nn-1)
    lista=[str(val)+b for b in bb]
  elif (np==nn-1):
    bb=codigo(nn-1)
    lista=[b+str(val) for b in bb]
  else:
    bb1=codigo(np)
    bb2=codigo(nn-np-1)
    lista=[]
    for b1 in bb1:
      for b2 in bb2:
        lista.append(b1+str(val)+b2)

  return lista

codigoInt(4,1,1)

# cambiar de lista binaria a decimal
def codigo_d(bb):
  mb=[int(b,2) for b in bb]
  return mb

bb=codigoInt(4,1,1)
codigo_d(bb)

# funcion para mostrar los nombres de las variables
def nomRed(Redc):
  nom=[]
  for r in Redc:
    nom.append(r[0])
  return nom

lista=nomRed(Red)
lista

# calculo de probabilidad d enodo a partir de sus nodos fusionados
def prob(pp,nom,val):
  # pp es una lista compuesta de sublistas donde el primero es el nombre del nodo fusionado, nom es uno el nombre de los nodos y val es el valor  0 o 1

  for i,r in enumerate(pp):
    if (nom in r[1]):
      indr=i
      break

  n=len(pp[indr][1])
  if n==1:
    valp=pp[indr][2][val]
  else:
    suma=0
    np=pp[indr][1].index(nom)
    bb=codigoInt(n,np,val)
    bd=codigo_d(bb)
    for d in bd:
      suma=suma+pp[indr][2][d]
    valp=suma

  return valp

from itertools import product
import math

# determinar probabilidad a partir de nodos padres
def prob_p(Redc, ind, pp):
  # Redc es la red a probar, ind es elnumero de la variable en la red a calcular , pp es la lista de probabilidades
  res=[]
  res.append(Redc[ind][0])
  res.append(Redc[ind][1])
  nn=len(Redc[ind][2])


  if (nn==0):
    res.append(Redc[ind][3])
  else:
    var=nomRed(Redc)
    padres=Redc[ind][2]
    mp=len(padres)
    indi=[var.index(x) for x in padres]
    fus=[Redc[indd][1] for indd in indi]
    mm=len(Redc[ind][1])
    binf=codigo(mm)


    bfath=[]
    bfathp=[]
    for j in range(mp):
      jj=indi[j]
      mp1=len(pp[jj][1])
      bb=codigo(mp1)
      bfath.append(bb)
      bfathp.append(pp[jj][2])


    # Combinaciones de texto
    combinaciones_texto = list(product(*bfath))

    # Combinaciones de números
    combinaciones_numeros = list(product(*bfathp))


    # Ahora combinamos todo:
    bfatht = [''.join(elem) for elem in combinaciones_texto]
    bfatht_numerico = [math.prod(numeros) for numeros in combinaciones_numeros]


    res.append([])

    for i,bb in enumerate(binf):
      # este falta de resolver
      lista=[b+bb for b in bfatht]
      lista_dec=codigo_d(lista)
      numerico=[Redc[ind][3][u] for u in lista_dec]
      resultado = [x * y for x, y in zip(numerico, bfatht_numerico)]
      suma=sum(resultado)
      res[2].append(suma)






  return res

# determinar probabilidad marginal
def probabilidad_marginal(Redc):
  pp=[]
  for ind,r in enumerate(Redc):
    res=prob_p(Redc, ind, pp)
    pp.append(res)

  return pp

# propagacion interna en nodos
def propagacion_interna(Redc,ind,var,val,pp):
  # Redc es la red a probar, ind es elnumero de la variable en la red a calcular , pp es la lista de probabilidades
  # var seria la variable de los nodos a considerar, val seria el valor a tomar

  p=[]
  if (len(Redc[ind][1])==1):
    p=[1-val,val]

  else:
    r=Redc[ind][1]
    np=r.index(var)
    nn=len(r)
    bb=codigoInt(nn,np,val)
    indices=codigo_d(bb)


    nt=len(pp[ind][2])
    pr=nt*[0]


    for i in indices:
      pr[i] = pp[ind][2][i]

    suma = sum(pr)
    pr = [x / suma for x in pr]
    p=pr


  return p

# determinar la propagacion de evidencia hacia adelante
def prob_hacia_adelante(Redc, ind, pp):
  res=prob_p(Redc, ind, pp)

  return res

import copy

# determinar la propagacion de evidencia lateral
def prob_lateral(Redc, ind, pp, var):
  # Redc es la red , ind es el numero de indice del hijo, pp es lista de probabilidades, var es variable de propagacion de evidencia debe ser uno de los padres del hijo
  # var es un nodo fusionado, definir los laterales
  lista=nomRed(Redc)   # poner la lista de posiciones de la variable
  fusion=Redc[ind][1]  # nodos fusionados
  n=len(fusion)
  bhij=codigo(n)         # lista de codigos binarios
  padres=Redc[ind][2]  # nodos padres
  resp={}
  for r in padres:
    res=[]
    if (r!=var):
      indr=lista.index(r)          # posicion de nodo en la red
      nn=len(Redc[indr][1])
      bbr=codigo(nn)               # lista d ecodigo binario en determinado nodo padre
      ppr=pp[indr][2]              # lista de probabilidades, mismo tamaño que el de codigo

      for i,bbi in enumerate(bbr):
        pb=[]
        pf=[]
        nnt=0
        for rr in padres:
          if (rr==r):
            pb.append(bbi)
            pf.append(ppr[i])
            indv=lista.index(rr)
            nn=len(Redc[indv][1])
            nnt=nnt+nn
          else:
            indv=lista.index(rr)
            nn=len(Redc[indv][1])
            nnt=nnt+nn
            bb=codigo(nn)
            pb.append(bb)
            pf.append(pp[indv][2])


        # Combinaciones de texto
        pb2 = [ [x] if isinstance(x, str) else x for x in pb ]
        combinaciones_texto = [''.join(tupla) for tupla in product(*pb2)]
        # Combinaciones de números
        pf2 = [ [x] if isinstance(x, float) else x for x in pf ]
        combinaciones_prob = list(product(*pf2))
        combinaciones_numeros = [float(np.prod(comb)) for comb in combinaciones_prob]

        # Ahora combinamos todo:
        bfatht = combinaciones_texto
        bfatht_numerico = combinaciones_numeros

        # hasta aqui vamos
        lista1=[]
        for bb in bfatht:
          suma=0

          for bb1 in bhij:
            num1=int(bb+bb1,2)
            suma=suma+Redc[ind][3][num1]
          lista1.append(suma)
        resultado = [a * b for a, b in zip(lista1, bfatht_numerico)]
        suma=sum(resultado)
        res.append(suma)

      resp[r]=res

  return resp

# determinar la propagacion de evidencia lateral, los coeficientes
def prob_lateral_coef(Redc, ind, pp, ppv, var):
  # Redc es la red , ind es el numero de indice del hijo, pp es lista de probabilidades, ppv es la anterior lista de probabilidades
  # recordar que para la variable padre de propagacion tendra el mismo valor enpp y en ppv
  # tienes que especificar cual variable no va en la actualizacion del coeficiente y esa va en var
  lista=nomRed(Redc)   # poner la lista de posiciones de la variable
  padres=Redc[ind][2]  # nodos padres
  pb=[]
  ppa=[]
  ppn=[]
  pf=[]
  for r in padres:
    indv=lista.index(r)
    nn=len(Redc[indv][1])
    bb=codigo(nn)
    pb.append(bb)
    if (r!=var):
      ppa.append(ppv[indv][2])
      ppn.append(pp[indv][2])
    else:
      ppa.append(len(ppv[indv][2])*[1])
      ppn.append(len(pp[indv][2])*[1])



  # Combinaciones de texto
  combinaciones_texto = list(product(*pb))
  bfatht = [''.join(elem) for elem in combinaciones_texto]
  # Combinaciones de números
  combinaciones_numerosv = list(product(*ppa))
  bfatht_numerico_a = [math.prod(numeros) for numeros in combinaciones_numerosv]
  # Combinaciones de números
  combinaciones_numerosn = list(product(*ppn))
  bfatht_numerico_n = [math.prod(numeros) for numeros in combinaciones_numerosn]
  # Ahora combinamos todo:


  nfus=len(Redc[ind][1])
  bb=codigo(nfus)
  coef=copy.deepcopy(Redc[ind][3])
  for bp in bfatht:
    num1=int(bp,2)
    for bh in bb:
      num2=int(bp+bh,2)
      if (bfatht_numerico_n[num1]==0):
        coef[num2]=Redc[ind][3][num2]
      else:
        coef[num2]=Redc[ind][3][num2]*bfatht_numerico_a [num1]/bfatht_numerico_n[num1]


  return coef

# determinar la propagacion de evidencia hacia atras coeficientes
def prob_hacia_atras_coef(Redc, ind, pp, ppv):
  # Redc es la red , ind es el numero de indice del hijo, pp es lista de probabilidades, ppv es la anterior lista de probabilidades
  lista=nomRed(Redc)   # poner la lista de posiciones de la variable
  padres=Redc[ind][2]  # nodos padres
  pb=[]
  ppa=[]
  ppn=[]
  pf=[]
  for r in padres:
    indv=lista.index(r)
    nn=len(Redc[indv][1])
    bb=codigo(nn)
    pb.append(bb)
    ppa.append(ppv[indv][2])
    ppn.append(pp[indv][2])


  # Combinaciones de texto
  combinaciones_texto = list(product(*pb))
  bfatht = [''.join(elem) for elem in combinaciones_texto]
  # Combinaciones de números
  combinaciones_numerosv = list(product(*ppa))
  bfatht_numerico_a = [math.prod(numeros) for numeros in combinaciones_numerosv]
  # Combinaciones de números
  combinaciones_numerosn = list(product(*ppn))
  bfatht_numerico_n = [math.prod(numeros) for numeros in combinaciones_numerosn]
  # Ahora combinamos todo:


  nfus=len(Redc[ind][1])
  bb=codigo(nfus)
  coef=copy.deepcopy(Redc[ind][3])
  for bp in bfatht:
    num1=int(bp,2)
    for bh in bb:
      num2=int(bp+bh,2)
      num3=int(bh,2)
      if (bfatht_numerico_n[num1]==0) or (ppv[ind][2][num3]==0):
        coef[num2]=Redc[ind][3][num2]
      else:
        coef[num2]=Redc[ind][3][num2]*bfatht_numerico_a [num1]/bfatht_numerico_n[num1]*pp[ind][2][num3]/ppv[ind][2][num3]


  return coef

# determinar la propagacion de evidencia hacia atras
def prob_hacia_atras(Redc, ind, ppv,pp):
  # Redc es la red , ind es el numero de indice del hijo, pp es lista de probabilidades, ppv es la anterior lista de probabilidades
  lista=nomRed(Redc)   # poner la lista de posiciones de la variable
  fus=Redc[ind][1]
  nfus=len(fus)
  bbi=codigo(nfus)
  padres=Redc[ind][2]  # nodos padres
  res={}
  for r in padres:
    indvr=lista.index(r)
    fus=Redc[indvr][1]
    nfus=len(fus)
    bb=codigo(nfus)
    pb=[]
    pf=[]
    res[r]=[]
    for b in bb:
      pb=[]
      pf=[]
      numb=int(b,2)
      for rr in padres:
        if (rr==r):
          pb.append(b)
          pf.append([1])
        else:
          indv=lista.index(rr)
          nn=len(Redc[indv][1])
          bb=codigo(nn)
          pb.append(bb)
          pf.append(pp[indv][2])
      # Combinaciones de texto
      pb2 = [ [x] if isinstance(x, str) else x for x in pb ]
      combinaciones_texto = [''.join(tupla) for tupla in product(*pb2)]
      bfatht = combinaciones_texto
      # Combinaciones de números
      pf2 = [ [x] if isinstance(x, float) else x for x in pf ]
      combinaciones_prob = list(product(*pf2))
      combinaciones_numeros = [float(np.prod(comb)) for comb in combinaciones_prob]
      bfatht_numerico=combinaciones_numeros
      # Ahora combinamos todo:


      # me estoy haciendo bolas
      resa=[]
      for bi in bbi:
        num1=int(bi,2)
        prodc=[]
        for jf,bf in enumerate(bfatht):
          num=int(bf+bi,2)
          Redd=copy.deepcopy(Redc[ind][3][num])
          prodc.append(Redd*bfatht_numerico[jf])
        suma=sum(prodc)
        resa.append(suma)

      nni=len(bbi)
      suma=0
      for i in range(nni):
        if (ppv[ind][2][i]!=0):
          suma=suma+resa[i]*pp[ind][2][i]/ppv[ind][2][i]

      res[r].append(suma*ppv[indvr][2][numb])

  return res

# determinar probabilidad a partir de nodos padres
def prob_p(Redc, ind, pp):
  # Redc es la red a probar, ind es elnumero de la variable en la red a calcular , pp es la lista de probabilidades
  res=[]
  res.append(Redc[ind][0])
  res.append(Redc[ind][1])
  nn=len(Redc[ind][2])



  if (nn==0):
    res.append(Redc[ind][3])

  else:
    var=nomRed(Redc)
    padres=Redc[ind][2]
    mp=len(padres)
    indi=[var.index(x) for x in padres]
    fus=[Redc[indd][1] for indd in indi]
    mm=len(Redc[ind][1])
    binf=codigo(mm)



    bfath=[]
    bfathp=[]
    for j in range(mp):
      jj=indi[j]
      mp1=len(pp[jj][1])
      bb=codigo(mp1)
      bfath.append(bb)
      bfathp.append(pp[jj][2])


    # Combinaciones de texto
    combinaciones_texto = list(product(*bfath))

    # Combinaciones de números
    combinaciones_numeros = list(product(*bfathp))


    # Ahora combinamos todo:
    bfatht = [''.join(elem) for elem in combinaciones_texto]
    bfatht_numerico = [math.prod(numeros) for numeros in combinaciones_numeros]


    res.append([])

    for i,bb in enumerate(binf):
      # este falta de resolver
      lista=[b+bb for b in bfatht]
      lista_dec=codigo_d(lista)
      numerico=[Redc[ind][3][u] for u in lista_dec]
      resultado = [x * y for x, y in zip(numerico, bfatht_numerico)]
      suma=sum(resultado)
      res[2].append(suma)

  return res

# determinar probabilidad marginal
def probabilidad_marginal(Redc):
  pp=[]
  for ind,r in enumerate(Redc):
    res=prob_p(Redc, ind, pp)

    pp.append(res)

  return pp

"""**THIRD PART: CALCULATION OF PROBABILITIES IN THE BAYESIAN NETWORK**"""

ppm=probabilidad_marginal(Red)

ppm

Red

# propagacion marginal
dir={}
dir['A']=round(prob(ppm,'A',1),4)
dir['B']=round(prob(ppm,'B',1),4)
dir['C']=round(prob(ppm,'C',1),4)
dir['D']=round(prob(ppm,'D',1),4)
dir['E']=round(prob(ppm,'E',1),4)
dir['F']=round(prob(ppm,'F',1),4)
dir['G']=round(prob(ppm,'G',1),4)
dir['H']=round(prob(ppm,'H',1),4)
dir['I']=round(prob(ppm,'I',1),4)
dir['J']=round(prob(ppm,'J',1),4)
dir['K']=round(prob(ppm,'K',1),4)

df['MP NM']=dir

df

"""Calculation of  probabilities D=1"""

# calculo para D=1 solo propagacion hacia adelante y no es necesario actualizar los coeficientes
dir={}
ppm0=copy.deepcopy(ppm)
# los que no fueron calculados
dir['F']=round(prob(ppm0,'F',1),4)
dir['E']=round(prob(ppm0,'E',1),4)
dir['A']=round(prob(ppm0,'A',1),4)
dir['C']=round(prob(ppm0,'C',1),4)
dir['B']=round(prob(ppm0,'B',1),4)
###
ppm0[3][2]=propagacion_interna(Red,3,'D',1,ppm0)
dir['D']=round(prob(ppm0,'D',1),4)
res=prob_hacia_adelante(Red, 6, ppm0)
ppm0[6][2]=copy.deepcopy(res[2])
dir['G']=round(prob(ppm0,'G',1),4)
res=prob_hacia_adelante(Red, 7, ppm0)
ppm0[7][2]=copy.deepcopy(res[2])
dir['H']=round(prob(ppm0,'H',1),4)
res=prob_hacia_adelante(Red, 8, ppm0)
ppm0[8][2]=copy.deepcopy(res[2])
dir['I']=round(prob(ppm0,'I',1),4)
res=prob_hacia_adelante(Red, 9, ppm0)
ppm0[9][2]=copy.deepcopy(res[2])
dir['J']=round(prob(ppm0,'J',1),4)
res=prob_hacia_adelante(Red, 10, ppm0)
ppm0[10][2]=copy.deepcopy(res[2])
dir['K']=round(prob(ppm0,'K',1),4)


df['D NM']=dir

"""Calculation of  probabilities D=1, F=1"""

# calculo para  F=1 agregado al anterior solo propagacion hacia adelante y no es necesario actualizar los coeficientes
Red1=copy.deepcopy(Red)
dir={}
ppm1=copy.deepcopy(ppm0)
# los que no fueron calculados
dir['D']=round(prob(ppm1,'D',1),4)
dir['E']=round(prob(ppm1,'E',1),4)
dir['A']=round(prob(ppm1,'A',1),4)
dir['C']=round(prob(ppm1,'C',1),4)
dir['B']=round(prob(ppm1,'B',1),4)
###
ppm1[5][2]=propagacion_interna(Red,5,'F',1,ppm1)
dir['F']=round(prob(ppm1,'F',1),4)
res=prob_hacia_adelante(Red, 6, ppm1)
ppm1[6][2]=copy.deepcopy(res[2])
dir['G']=round(prob(ppm1,'G',1),4)
res=prob_hacia_adelante(Red, 7, ppm1)
ppm1[7][2]=copy.deepcopy(res[2])
dir['H']=round(prob(ppm1,'H',1),4)

res=prob_hacia_adelante(Red, 8, ppm1)
ppm1[8][2]=copy.deepcopy(res[2])
dir['I']=round(prob(ppm1,'I',1),4)
res=prob_hacia_adelante(Red, 9, ppm1)
ppm1[9][2]=copy.deepcopy(res[2])
dir['J']=round(prob(ppm1,'J',1),4)
res=prob_hacia_adelante(Red, 10, ppm1)
ppm1[10][2]=copy.deepcopy(res[2])
dir['K']=round(prob(ppm1,'K',1),4)


df['DF NM']=dir

"""Calculation of  probabilities D=1, F=1 and J=1"""

# calculo para  J=1 agregado al anterior solo propagacion hacia atras y no es necesario porpagacion lateral
dir={}
ppm2=copy.deepcopy(ppm1)
ppm2[9][2]=propagacion_interna(Red,9,'F',1,ppm2)
dir['J']=round(prob(ppm2,'J',1),4)

dir['B']=round(prob(ppm2,'B',1),4)
res=prob_hacia_adelante(Red, 10, ppm2)
ppm2[10][2]=copy.deepcopy(res[2])
dir['K']=round(prob(ppm2,'K',1),4)

res=prob_hacia_atras(Red, 9, ppm1,ppm2)   # lo pusiste al reves
ppm2[8][2]=res['I']
dir['I']=round(prob(ppm2,'I',1),4)
ppm2[2][2]=res['C']
dir['C']=round(prob(ppm2,'C',1),4)

res=prob_hacia_atras(Red, 8, ppm1,ppm2)   # lo pusiste al reves
ppm2[7][2]=res['H']
dir['H']=round(prob(ppm2,'H',1),4)
ppm2[0][2]=res['A']
dir['A']=round(prob(ppm2,'A',1),4)

res=prob_hacia_atras(Red, 7, ppm1,ppm2)   # lo pusiste al reves
ppm2[6][2]=res['G']
dir['G']=round(prob(ppm2,'G',1),4)
ppm2[4][2]=res['E']
dir['E']=round(prob(ppm2,'E',1),4)

res=prob_hacia_atras(Red, 6, ppm1,ppm2)   # lo pusiste al reves
ppm2[5][2]=res['F']
dir['F']=round(prob(ppm2,'F',1),4)
ppm2[3][2]=res['D']
dir['D']=round(prob(ppm2,'D',1),4)



df['DFJ NM']=dir


coef=prob_hacia_atras_coef(Red, 9, ppm2, ppm1)
Red[9][3]=copy.deepcopy(coef)
coef=prob_hacia_atras_coef(Red, 8, ppm2, ppm1)
Red[8][3]=copy.deepcopy(coef)
coef=prob_hacia_atras_coef(Red, 7, ppm2, ppm1)
Red[7][3]=copy.deepcopy(coef)
coef=prob_hacia_atras_coef(Red, 6, ppm2, ppm1)
Red[6][3]=copy.deepcopy(coef)

df

lista=["DF BN",	"DFJ BN",	"DF NM",	"DFJ NM"]
latex_code = df[lista].to_latex(index=True, float_format="%.4f")
print(latex_code)

gnb.showBN(bn)

"""**FOURTH PART: MPE CALCULATION STARTING FROM EVIDENCE NODE J**"""

Ruta={}
Prob={}
Ruta1={}
Prob1={}
Ruta2={}
Prob2={}
# J =1 es nodo evidencia, procedemos a calcular al reves, vendrian los nodos I y C
Ruta['J']=1
Ruta['C']=0
Ruta['I']=1
Prob['J-C-I']=Red[9][3][3]*ppm2[2][2][0]*ppm2[8][2][1]
Ruta1['J']=1
Ruta1['C']=1
Ruta1['I']=0
Prob1['J-C-I']=Red[9][3][5]*ppm2[2][2][1]*ppm2[8][2][0]
Ruta2['J']=1
Ruta2['C']=1
Ruta2['I']=1
Prob2['J-C-I']=Red[9][3][7]*ppm2[2][2][1]*ppm2[8][2][1]
print(round(Prob['J-C-I'],4))
print(round(Prob1['J-C-I'],4))
print(round(Prob2['J-C-I'],4))
print(round(Prob1['J-C-I']+Prob2['J-C-I'],4))

# la mas prometedora es la ruta 1, el valor mas alto de probabilidad, pero esta ya no tiene mas continuaciones, asi continuemos con la ruta que es la segunda mejor
Ruta['A']=1
Ruta['H']=1
Prob['J-C-I-A-H']=Red[9][3][3]*ppm2[2][2][0]*Red[8][3][7]*ppm2[0][2][1]*ppm2[7][2][1]
print(round(Prob['J-C-I-A-H'],4))

# continuacion de ruta
Ruta['E']=0
Ruta['G']=1   # forzosamente toma ese valor
Prob['J-C-I-A-H-E-G']=Red[9][3][3]*ppm2[2][2][0]*Red[8][3][7]*ppm2[0][2][1]*Red[7][3][3]*ppm2[4][2][0]*ppm2[6][2][1]
print(round(Prob['J-C-I-A-H-E-G'],4))
Ruta3=copy.deepcopy(Ruta)
Ruta3['E']=1
Prob3=copy.deepcopy(Prob)
Prob['J-C-I-A-H-E-G']=Red[9][3][3]*ppm2[2][2][0]*Red[8][3][7]*ppm2[0][2][1]*Red[7][3][3]*ppm2[4][2][1]*ppm2[6][2][1]
print(round(Prob['J-C-I-A-H-E-G'],4))